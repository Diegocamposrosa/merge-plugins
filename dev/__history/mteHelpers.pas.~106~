unit mteHelpers;

interface

uses
  Windows, SysUtils, ShlObj, Classes,
  wbBSA,
  wbHelpers,
  wbInterface,
  wbImplementation,
  wbDefinitionsFNV,
  wbDefinitionsFO3,
  wbDefinitionsTES3,
  wbDefinitionsTES4,
  wbDefinitionsTES5;

type
  TMerge = class(TObject)
    public
      name: string;
      filename: string;
      dateBuilt: TDateTime;
      plugins: TStringList;
      pluginSizes: TList;
      pluginDates: TStringList;
      masters: TStringList;
      method: string;
      renumbering: string;
      log: string;
      constructor Create; virtual;
  end;
  TPluginFlag = (IS_BLACKLISTED, HAS_ERRORS, HAS_BSA, HAS_MCM, HAS_FACEDATA,
    HAS_VOICEDATA, HAS_FRAGMENTS);
  TPluginFlags = set of TPluginFlag;
  TPlugin = class(TObject)
    public
      pluginFile: IwbFile;
      hasData: boolean;
      fileSize: Int64;
      dateModified: string;
      flags: TPluginFlags;
      filename: string;
      numRecords: string;
      numOverrides: string;
      author: string;
      description: string;
      masters: TStringList;
      errors: TStringList;
      reports: TStringList;
      constructor Create; virtual;
      procedure GetData(blacklist: TStringList; bCountOverrides: boolean);
      procedure GetFlags(blacklist: TStringList);
      function GetFlagsString: string;
      procedure UpdateErorrs;
  end;

  function IsOverride(aRecord: IwbMainRecord): boolean;
  function CountOverrides(aFile: IwbFile): integer;
  procedure GetMasters(aFile: IwbFile; var sl: TStringList);
  function BSAExists(filename: string): boolean;
  function MCMExists(filename: string): boolean;
  function FaceDataExists(filename: string): boolean;
  function VoiceDataExists(filename: string): boolean;
  function FragmentsExist(filename: string): boolean;
  function CheckForErrorsLinear(const aElement: IwbElement; LastRecord: IwbMainRecord; var errors: TStringList): IwbMainRecord;
  function CheckForErrors(const aIndent: Integer; const aElement: IwbElement; var errors: TStringList): Boolean;
  function PluginByName(plugins: TList; name: string): TPlugin;
  function PluginsModified(plugins: TList; merge: TMerge): boolean;
  function csvText(s: string): string;
  function FormatByteSize(const bytes: Int64): string;
  function DateBuiltString(date: TDateTime): string;
  function GetCSIDLShellFolder(CSIDLFolder: integer): string;
  function GetFileSize(const aFilename: String): Int64;
  function GetLastModified(const aFileName: String): TDateTime;


implementation

{******************************************************************************}
{ Bethesda Plugin Functions
  Set of functions that read bethesda plugin files for various attributes.

  List of functions:
  - IsOverride
  - CountOverrides
  - GetMasters
  - BSAExists
  - MCMExists
  - FaceDataExists
  - VoiceDataExists
  - FragmentsExist
  - CheckForErorrsLinear
  - CheckForErrors
}
{*****************************************************************************}

{
  Returns true if the input record is an override record
}
function IsOverride(aRecord: IwbMainRecord): boolean;
begin
  Result := not aRecord.Equals(aRecord.MasterOrSelf);
end;

{
  Returns the number of override records in a file
}
function CountOverrides(aFile: IwbFile): integer;
var
  i: Integer;
  aRecord: IwbMainRecord;
begin
  Result := 0;
  for i := 0 to Pred(aFile.GetRecordCount) do begin
    aRecord := aFile.GetRecord(i);
    if IsOverride(aRecord) then
      Inc(Result);
  end;
end;

{
  Gets the masters in an IwbFile and puts them into a stringlist
}
procedure GetMasters(aFile: IwbFile; var sl: TStringList);
var
  Container, MasterFiles, MasterFile: IwbContainer;
  i: integer;
begin
  Container := aFile as IwbContainer;
  Container := Container.Elements[0] as IwbContainer;
  if Container.ElementExists['Master Files'] then begin
    MasterFiles := Container.ElementByPath['Master Files'] as IwbContainer;
    for i := 0 to MasterFiles.ElementCount - 1 do begin
      MasterFile := MasterFiles.Elements[i] as IwbContainer;
      sl.Add(MasterFile.GetElementEditValue('MAST - Filename'));
    end;
  end;
end;

{
  Checks if a BSA exists associated with the given filename
}
function BSAExists(filename: string): boolean;
begin
  if (Pos('.esp', filename) > 0)
  or (Pos('.esm', filename) > 0) then
    filename := Copy(filename, 1, Length(filename) - 4) + '.bsa'
  else
    filename := filename + '.bsa';
  Result := FileExists(wbDataPath + filename);
end;

function MCMExists(filename: string): boolean;
begin
  Result := false;
end;

function FaceDataExists(filename: string): boolean;
var
  facetint, facegeom: boolean;
begin
  facetint := DirectoryExists(wbDataPath + 'textures\actors\character\facegendata\facetint\' + filename);
  facegeom := DirectoryExists(wbDataPath + 'meshes\actors\character\facegendata\facegeom\' + filename);
  Result := facetint or facegeom;
end;

function VoiceDataExists(filename: string): boolean;
begin
  Result := DirectoryExists(wbDataPath + 'sound\voice\' + filename);
end;

function FragmentsExist(filename: string): boolean;
begin
  Result := false;
end;

{
  Recursively traverse a container looking for errors
}
function CheckForErrorsLinear(const aElement: IwbElement;
  LastRecord: IwbMainRecord; var errors: TStringList): IwbMainRecord;
var
  Error: string;
  Container: IwbContainerElementRef;
  i: Integer;
begin
  Error := aElement.Check;
  if Error <> '' then begin
    Result := aElement.ContainingMainRecord;
    // first error in this record - show record's name
    if Assigned(Result) and (Result <> LastRecord) then begin
      errors.Add(Result.Name);
    end;
    errors.Add('    ' + aElement.Path + ' -> ' + Error);
  end else
    // passing through last record with error
    Result := LastRecord;
  if Supports(aElement, IwbContainerElementRef, Container) then
    for i := 0 to Pred(Container.ElementCount) do
      Result := CheckForErrorsLinear(Container.Elements[i], Result, errors);
end;

function CheckForErrors(const aIndent: Integer; const aElement: IwbElement;
  var errors: TStringList): Boolean;
var
  Error: string;
  Container: IwbContainerElementRef;
  i: Integer;
begin
  Error := aElement.Check;
  Result := Error <> '';
  if Result then begin
    Error := aElement.Check;
    errors.Add(StringOfChar(' ', aIndent * 2) + aElement.Name + ' -> ' + Error);
  end else
    errors.Add('');

  // recursion
  if Supports(aElement, IwbContainerElementRef, Container) then
    for i := Pred(Container.ElementCount) downto 0 do
      Result := CheckForErrors(aIndent + 1, Container.Elements[i], errors) or Result;

  if Result and (Error = '') then begin
    errors.Add(StringOfChar(' ', aIndent * 2) + 'Above errors were found in :' + aElement.Name);
  end;
end;

{
  Gets a plugin matching the given name.
}
function PluginByName(plugins: TList; name: string): TPlugin;
var
  i: integer;
  plugin: TPlugin;
begin
  Result := nil;
  for i := 0 to Pred(plugins.count) do begin
    plugin := TPlugin(plugins[i]);
    if plugin.filename = name then begin
      Result := plugin;
      exit;
    end;
  end;
end;

{
  Checks to see if the plugins in a merge have been modified since it was last
  merged.
}
function PluginsModified(plugins: TList; merge: TMerge): boolean;
var
  plugin: TPlugin;
  i: integer;
begin
  Result := false;
  for i := 0 to Pred(merge.plugins.count) do begin
    plugin := PluginByName(plugins, merge.plugins[i]);
    if Assigned(plugin) then begin
      if plugin.dateModified <> merge.pluginDates[i] then
        Result := true;
    end;
  end;
end;

{******************************************************************************}
{ Data type functions
  Set of functions that help with converting data formats.

  List of functions:
  - csvText
  - FormatByteSize
  - DateBuiltString
}
{*****************************************************************************}

{
  Replaces newlines with a comma and space
}
function csvText(s: string): string;
begin
  result := StringReplace(Trim(s), #13, ', ', [rfReplaceAll]);
end;

{
  Format file byte size
}
function FormatByteSize(const bytes: Int64): string;
const
 B = 1; //byte
 KB = 1024 * B; //kilobyte
 MB = 1024 * KB; //megabyte
 GB = 1024 * MB; //gigabyte
begin
 if bytes > GB then
   result := FormatFloat('#.## GB', bytes / GB)
 else
   if bytes > MB then
     result := FormatFloat('#.## MB', bytes / MB)
   else
     if bytes > KB then
       result := FormatFloat('#.## KB', bytes / KB)
     else
       result := FormatFloat('#.## bytes', bytes) ;
end;

{
  Converts a TDateTime to a string, with 0 being the string 'Never'
}
function DateBuiltString(date: TDateTime): string;
begin
  if date = 0 then
    Result := 'Never'
  else begin
    Result := DateTimeToStr(date);
  end;
end;


{******************************************************************************}
{ Windows API functions
  Set of functions that help deal with the Windows File System.

  List of functions:
  - GetCSIDLShellFolder
  - GetFileSize
  - GetLastModified
}
{******************************************************************************}

{
  Gets a folder by its integer CSID.
}
function GetCSIDLShellFolder(CSIDLFolder: integer): string;
begin
  SetLength(Result, MAX_PATH);
  SHGetSpecialFolderPath(0, PChar(Result), CSIDLFolder, True);
  SetLength(Result, StrLen(PChar(Result)));
  if (Result <> '') then
    Result := IncludeTrailingBackslash(Result);
end;

{
  Gets the size of a file at @aFilename through the windows API
}
function GetFileSize(const aFilename: String): Int64;
var
  info: TWin32FileAttributeData;
begin
  result := -1;

  if NOT GetFileAttributesEx(PWideChar(aFileName), GetFileExInfoStandard, @info) then
    EXIT;

  result := Int64(info.nFileSizeLow) or Int64(info.nFileSizeHigh shl 32);
end;

{
  Gets the last time a file was modified
}
function GetLastModified(const aFileName: String): TDateTime;
var
  info: TWin32FileAttributeData;
  FileTime: TFileTime;
  LocalTime, SystemTime: TSystemTime;
begin
  result := 0;

  if NOT GetFileAttributesEx(PWideChar(aFileName), GetFileExInfoStandard, @info) then
    EXIT;

  FileTime := info.ftLastWriteTime;

  if not FileTimeToSystemTime(FileTime, SystemTime) then
    RaiseLastOSError;
  if not SystemTimeToTzSpecificLocalTime(nil, SystemTime, LocalTime) then
    RaiseLastOSError;

  Result := SystemTimeToDateTime(LocalTime);
end;


{******************************************************************************}
{ Object functions
  Set of functions for objects TMerge and TPlugin

  List of functions:
  - TMerge.Create
  - TPlugin.Create
  - TPlugin.GetFlags
  - TPlugin.GetFlagsString
  - TPlugin.GetData
}
{******************************************************************************}

constructor TMerge.Create;
begin
  name := 'NewMerge';
  filename := 'NewMerge.esp';
  dateBuilt := 0;
  plugins := TStringList.Create;
  pluginSizes := TList.Create;
  pluginDates := TStringList.Create;
  masters := TStringList.Create;
  method := 'Overrides';
  renumbering := 'Conflicting';
  log := '';
end;

constructor TPlugin.Create;
begin
  hasData := false;
  masters := TStringList.Create;
  errors := TStringList.Create;
  reports := TStringList.Create;
end;

{
  Gets the flag values for a TPlugin
}
procedure TPlugin.GetFlags(blacklist: TStringList);
begin
  if blacklist.IndexOf(filename) > -1 then begin
    flags := flags + [IS_BLACKLISTED];
    exit;
  end;
  if errors.Count > 0 then
    flags := flags + [HAS_ERRORS];
  if BSAExists(filename) then
    flags := flags + [HAS_BSA];
  if MCMExists(filename) then
    flags := flags + [HAS_MCM];
  if FaceDataExists(filename) then
    flags := flags + [HAS_FACEDATA];
  if VoiceDataExists(filename) then
    flags := flags + [HAS_VOICEDATA];
  if FragmentsExist(filename) then
    flags := flags + [HAS_FRAGMENTS];
end;

{
  Returns a string representing the flags in a plugin
}
function TPlugin.GetFlagsString: string;
begin
  Result := '';
  if IS_BLACKLISTED in flags then
    Result := Result + 'X';
  if HAS_ERRORS in flags then
    Result := Result + 'E';
  if HAS_BSA in flags then
    Result := Result + 'A';
end;

{
  Fetches data associated with a plugin.
}
procedure TPlugin.GetData(blacklist: TStringList; bCountOverrides: boolean);
var
  Container: IwbContainer;
begin
  hasData := true;
  filename := pluginFile.FileName;
  Container := pluginFile as IwbContainer;
  Container := Container.Elements[0] as IwbContainer;
  author := Container.GetElementEditValue('CNAM - Author');
  numRecords := Container.GetElementEditValue('HEDR - Header\Number of Records');
  description := Container.GetElementEditValue('SNAM - Description');
  GetMasters(pluginFile, masters);
  GetFlags(blacklist);

  // get file attributes
  fileSize := GetFileSize(wbDataPath + filename);
  dateModified := DateTimeToStr(GetLastModified(wbDataPath + filename));

  if bCountOverrides then
    numOverrides := IntToStr(CountOverrides(pluginFile));
end;

{
  Checks for errors in a plugin
}
procedure TPlugin.UpdateErrors;
begin
  CheckForErrors(0, pluginFile as IwbElement, errors);
end;

end.
